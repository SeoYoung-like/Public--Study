# 09-2. RAM

## 1. 가상 메모리 vs 물리 메모리 

* **가상 메모리는 무엇인가?**
  *  <u>CPU가 참조하는 메모리 주소값</u>을 가상 메모리(virtual memory) 라고 한다.



* **물리 메모리는 무엇인가?**
  * <u>실제 메모리의 주소값</u>을 물리 메모리(physical memory) 라고 한다.
  * 가상 메모리에서 물리 메모리를 사용하기 위해 일련의 변화 과정을 거친다.



* **페이징이란 무엇인가?** 1
  * 가상 메모리가 물리 메모리로 변환하는 방식 



* **페이지와 페이지 테이블을 설명하시오.**

  * 페이지(page) : 변환이 되는 최소의 메모리 단위
  * 페이지 테이블(page table) : 어떻게 변환을 수행할 지 기록한 테이블
    ( 각 프로그램 마다 하나씩 가지고 있다. )

  <img src="./assets/9.%20%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80%20%EB%AC%BC%EB%A6%AC%EB%A9%94%EB%AA%A8%EB%A6%AC2.png" alt="9. 가상메모리와 물리메모리2" style="zoom:67%;" />



* **페이징 기술의 장점은 무엇인가?** 1

  * 페이징 덕분에 각 프로그램들은 마치 자기 혼자서 메모리 전 공간을 사용하는 것 마냥 사용할 수 있다. 
  * 즉, 메모리에 같이 올라가 있는 다른 프로그램들을 전혀 고려할 필요 없이 매우 편리하게 프로그램을 개발할 수 있는 것이다.

  <img src="./assets/9.%20%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80%20%EB%AC%BC%EB%A6%AC%EB%A9%94%EB%AA%A8%EB%A6%AC1.png" alt="9. 가상메모리와 물리메모리1" style="zoom:67%;" />



* **[참고] 페이지 크기** ㅇ
  * 페이지의 크기는 여러가지로 설정할 수 있지만 대부분의 경우 1 페이지는 4 KB 정도 입니다.
  * 64 비트 시스템의 경우 사용 가능한 가상 메모리 크기는 대략 1844만 테라바이트 정도 됩니다. 아마 일반 사람이 이만한 크기의 메모리를 필요할 날은 한동안 오지 않을 것이다.







## 2.  Big-Endianness 와 Little-Endianness

* **[참고] 메모리 Byte order** ㅇ
  * 메모리에 따라 Byte order 읽는 순서가 순차적, 역순으로 다르게 저장된다.



* **Big endian( 빅 엔디안 )은 무엇인가?**
  * 낮은 주소에 데이터의 높은 바이트(MSB, Most Significant Bit)부터 저장하는 방식입니다.
  * 큰 수 부터 앞에서 저장 - 최상의 바이트를 저장공간의 가장 작은 메모리 주소(가장 앞)에 저장
  * IBM, SPARC 시스템 등에서 사용
  
    * 0x12345678
    * (ex) 12 34 56 78

![빅 엔디안](./assets/img_c_byteorder_big_endian.png)



* **Little endian( 리틀 엔디안 )은 무엇인가?**
  * 낮은 주소에 데이터의 낮은 바이트(LSB, Least Significant Bit)부터 저장하는 방식입니다.
  * 작은 수 부터 앞에서 저장 - 최상의 바이트를 저장공간의 가장 큰 메모리 주소(가장 뒤)에 저장
  * Intel x86/64, AMD 시스템 등에서 사용

    * 0x12345678
    * (ex) 78 56 34 12 

![리틀 엔디안](./assets/img_c_byteorder_little_endian.png)





* **네트워크 변환에서 무엇을 고려해야 하는가? **1
  * 상대 컴퓨터 메모리 형태에 맞게 네트워크 등으로 전달할 때 변환을 고려하게 된다. 
  * 그렇기 때문에 C언어에서는 각 엔디안에 맞는 변환 함수도 존재한다. 
