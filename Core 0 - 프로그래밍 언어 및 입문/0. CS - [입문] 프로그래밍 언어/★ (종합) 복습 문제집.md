# (종합) 복습 문제집 

## 01. 프로그래밍 언어의 특징

### 1. 프로그래밍 언어 계보

* **프로그래밍 언어 계보 떠올려 보세요.** [12]





### 2. 프로그래밍 언어 특징

* **프로그래밍 언어의 5가지 특징은 무엇이 있는가?** [12]
  1. Low Level  /  High Level
  2. Compiler  /  interpreter 
  3. Strong  /  Weak
  4. Managed  /  UnManaged
  5. Procedural / OOP / functional





#### 2.1. 저수준 언어 / 고수준 언어

* **저수준 언어와 고수준 언어의 차이는 무엇인가?** [12]
  * 문자 코드 / 숫자 코드
    * 저수준 언어는 숫자코드에 가까운 컴퓨터가 이해할 수 언어이다.
    * 고수준 언어는 문자코드로 인간이 이해하기 쉬운 언어로 구성 되어 있다.
  * 기계어로 1:1 대응 가능 한가?
  * 현세대 기준으로 인간친화적 인가? 
    * 상대적인 분류 방법이다.
    * 이때 어셈블리어, C언어가 저수준 언어로 평가 받기도 한다.





* **어셈블리 언어는 어떤 수준의 언어인가?** [12]
  * 기계어 일대일 대응 기준 : 저수준 언어
  * 문자 코드 사용 기준 : 고수준 언어





* **C언어는 어떤 수준의 언어인가?** [12]
  * 과거 기준 : 고수준 언어
  * 현대 기준 : 저수준 언어





#### 2.2. 컴파일 / JIT 컴파일 / 인터프리터

* **컴파일 / JIT 컴파일 / 인터프리터는 무엇인가?** [12]
  * 컴파일러가 고수준 언어(문자 코드 / 소스 코드)를 네이티브 코드(기계어)로 컴파일한다.
  * 컴파일 언어와 인터프리터 언어의 하이브리드 중간 형태라고 보면 된다.
  * 컴파일 단계가 없이 실행 시 고수준 언어를 네이트브 코드로 바꿔서 실행한다. ( 동시 통역으로 이해하면 편하다. )





* **컴파일 과정은 어떻게 되어 있는가?** [12]
  * [ 소스코드 ] - [ 컴파일러 ] - [ 기계어(exe) ] - [ 실행 ]



* **컴파일 언어의 장단점(2가지/2가지)는 무엇인가?** []

  * 장점

    1. 다양한 최적화 기능을 통한 빠른 실행
    2. 미리 실수 방지
  * 단점

    1. 아주 긴 컴파일 시간 - 1시간 이상

    2. 플랫폼(CPU, OS 등)에 맞는 컴파일 사용 : 실행할 수 있는 기계어가 다르다.
       * Native 언어로 주변 환경에 의존성을 가지게 된다. ( 즉, 하드웨어, OS 등이 동일해야 한다. )



* **컴파일 언어가 좋은 코드를 생산하기에 적합한 이유는?** [12]
  * 컴파일 단계에서 에러를 통해 버그를 미리 찾을 수 있다. 





* **JIT 컴파일 과정은 어떻게 되어 있는가?**  [12]
  * [ 소스코드 ] => [ 컴파일 ] => [ 중간코드(IL code) ] => [ **JIT 컴파일** ] => [ 기계어 ] => 실행 



* **JIT 컴파일의 대표적인 특징 2가지는 무엇인가?** []
  * '중간 언어 코드'를 컴파일 한다.
  * VM 종속 ( Virtual Machine )
    1. VM이 중간 언어를 기계가 이해하는 언어로 바꿔서 실행한다. 
    2. 플랫폼 별로 가상머신( Virtual Machine )을 설치해야 한다.





* **인터프리터 언어의 장단점은?** [12]
  * 장점
    1. 생산성이 좋다. ( 개발 속도가 빠르다. )
    2. 플랫폼에 독립적이다. ( 자유롭다. )
  * 단점
    1. 실행 속도가 느리다.
    2. 문제가 되는 코드를 컴파일 과정에서 해결할 수 없다.



* **인터프리터 언어가 좋은 코드를 생산하기에 적합한가?** []
  * 오프라인 컴파일러가 없어서 실제로 실행하기 전까지 코드의 문제를 잡아낼 수 없다.



* **JIT 컴파일과 인터프리터 탄생 배경은?** [12]

  * 컴파일 언어는 개발 환경과 실행 환경(CPU, OS)마다 각자 다른 컴파일러들을 사용해야만 하는 문제가 발생한다.

    결국, 인터프리터 방식을 통해 호환성 문제를 해결하려 하게 된다. ( JIT도 이와 동일하다. )



#### 2.3. 강한 타입 / 약한 타입

* **강한 타입(Strong-typed)과 약한 타입(Weak-typed)은 무엇인가?** [12]
  * 강한 / 약한 타이핑은 유형이 얼마나 엄격하게 구별되는지 에 관한 것입니다. 변수 선언(변수의 용도)과 관련 있다.
  * 강한 타입
    * 변수형을 선언 후 변수형 변경이 불가능 하다.
      엄격하게 구분한다.
    * C, C++, C#, Java 등
  * 약한 타입 
    * 변수형을 선언 후 변수형 변경이 가능하다.
      관대하게 구분한다.
    * JavaScript, Python 등



* **강한 타입(Strong-typed)과 약한 타입(Weak-typed)중 어떤 것이 더 실수를 잡기 편한가?** [12]
  * 상용 코드를 작성할 때는 강한 타입 언어들이 일반적으로 더 낫다.
    ( 컴파일 등을 활용해서 실수를 바로 잡기 편하다. )
  * 약한 타입을 사용하면 코드를 실행하기 전까지 실수를 찾을 수 없게 된다. ( 의도인지 실수인지 알기 어렵다. )



* **약한 타입(Weak-typed)의 장점은?** [1]
  * 강한 타입에 비해 신경 쓸 부분이 상대적으로 적기 때문에 1인 이나 취미로 개발할 때 등 빠르게 개발할 수 있다.





* **정적(Static)과 동적(Dynamic) 타입은 무엇인가?** [1]
  * type 정보가 수집되는 시점 (컴파일 타임 또는 런타임)에 관한 것입니다 .
  * **Statically typed** : 정적타입 언어는 컴파일 시 변수의 ‘타입’이 결정됩니다.
  * **Dynamically typed** : 동적타입 언어는 런타임 시 변수의 ‘타입’이 결정됩니다.



* **정적(Static)과 동적(Dynamic) 타입의 특징 및 장단점은?** []
* 정적타입 언어 사용 시 타입 에러는 '컴파일 시 에러'가 뜨기 때문에, 더 편하고 빠르게 에러 확인이 가능합니다. 

* 동적타입 언어는 런타임 시 확인할 수 밖에 없기 때문에, 이러한 불편함을 해소하기 위해 TypeScipt와 Flow같은 툴을 사용하게 된다.







#### 2.4. 매니지드 / 언매니지드



* **메모리 관리 핵심 2가지는 무엇인가?** [1]
  * **확보** - 프로그램에서 큰 데이터를 사용하기 위해 운영체제(OS)로 부터 독점적으로 사용할 메모리를 확보 할 수 있다.
  * **반환** - 데이터를 다 사용한 뒤에는 OS에 메모리를 반환 할 수 있다.





* **매니지드 언어와 언매니지드 언어의 차이는 무엇인가?** [12]
  * 매니지드 언어 : **프로그래밍 언어**가 더 이상 메모리를 사용하지 않는 상황( 어림짐작 )을 **자동으로 판단하여 메모리를 반환**한다.
  * 언매니지드 언어 : **프로그래머**가 책임지고 **메모리를 관리**하는 언어이다.



* **매니지드 언어와 언매니지드 언어 개발 선택시 중요점은?** [12]

  * 매니지드 언어 

    * 생산성

      성능이 크게 중요하지 않은 프로그램 개발 시 사용한다.
      잔실수 없어 편하며 개발 속도가 빠르다. ( 생산성이 높다. )

  * 언매니지드 언어

    * 성능

      성능이 중요한 프로그램 개발 시 사용한다.
      개발 속도가 빠르지 않지만 완성된 프로그램은 성능이 뛰어나다. ( 성능을 쥐어 짠다. )





* **매니지드 언어의 장단점은?** [1]
  * [장점] 개발 속도가 빠르고, 프로그래밍 실수가 적다.
    * 메모리 관리를 언어상에서 알아서 해주는 언어로 메모리에 대한 생각은 하지 않고 코드를 작성할 수 있다.
      컴퓨터의 깊은 구조를 모르고도 프로그램을 작성이 쉽게 할 수 있는 언어들이다.
    * 매니지드 언어가 프로그래밍 실수가 적고 편하다. 
  * [단점] 성능이 좋지 못하다.
    * 어림짐작이 명시적 표현보다 효율적일 수 없다.





* **언매니지드 언어의 장단점은?** [1]

  * [장점] 성능이 좋다.
    * 성능에서 효율적이며 속도가 뛰어난 프로그램을 개발 할 수 있다.
  * [단점] 개발 속도가 느리고, 치명적인 실수가 발생할 수도 있다.
    * 프로그래머가 실수를 할 경우 Memory Leak 이라는, 치명적인 문제가 발생할 수 있습니다. ( 명시적 표현 특성 상 일일이 말해야 하기 때문에 잊어버리고 실수 할 수 있다. )

  



* **언매지니드를 공부를 통한 학습 효과는?** [12]

  * 언매니지드 언어를 배우면 10년 뒤에도 대우 받는 프로그래머로 살아남기 위해 반드시 필요한 지식을 배울 수 있다.

  * **하드웨어 동작 원리**
    사용자가 직접적으로 하드웨어 CPU, Memory를 관리해야 한다. 
    그렇기 때문에 컴퓨터의 구조 혹은 관리하는 법을 깊게 배워야 한다. 

    * 메모리의 동작원리

    * CPU 동작 원리

  * **컴퓨터처럼 생각하는 법** 

    컴퓨터 처럼 생각하는 습관을 들이면, 그러지 못한 사람들 보다 빠르게 성장할 수 있다. 

  * **다양한 언어의 동작 원리**

    매니지드 언어에서 지원하는 모든 **기능들의 동작원리**
    결국 내부적으로는 언매니지드의 원리를 이해해야 한다.







#### 2.5. 프로그래밍 패러다임

* **프로그래밍 패러다임이란?** [12]
  * 관점이나 기능에 따라 분류하는 방식이다.



* **프로그래밍 패러다임은 각 언어 당 몇 개까지 적용할 수 있는가?** [12]
  * 프로그래밍 언어는 이런 패러다임을 하나 또는 여러 개를 지원한다.



* **절차지향 언어의 2가지 특징은 무엇인가?** []
  * 함수를 실행하면 <u>절차적인 순서에 따라 실행</u>해서 결과가 반환 된다.
  * 기능과 자료 저장(상태)의 분리
    * 결과로 나온 자료를 저장하고 싶으면 별도의 공간에 따로 저장할 수 있다. ( OOP에서는 같이 저장한다. )
    * 자료 저장(상태)을 어디다가 저장 하느냐를 심각히 고민하지 않는 언어이다.



* **개체 지향 언어란 무엇인가?** [12]
  * 절차적인 언어는 기계 관점 위주로 돌았다면 이걸 개체라는 인간의 관점으로 바라보는 언어이다.
  * 가장 널리 쓰이는 프로그래밍 패러다임

    * 사람에게 매우 직관적이다.
    * 미리 만들어 진 여러가지를 재활용하기 때문에 복잡한 프로그램의 구조를 잡기 쉽다.
  * OOP언어라고 불리는 것들은 OOP적인 문법을 강제하는 언어이다.



* **클래스와 개체는 무엇인가?** [12]
  * 개체
    * 자료 저장(상태)과 기능을 하나의 개체(Object)에 합침
    * 물체의 개념
  * 클래스
    * 개체는 이 클래스라는 '틀, 설계도'를 통해 완성된다.
    * 클래스는 공통적으로 사용되는 속성이나 메소드(기능)를 미리 만들어 둘 수 있다.
    * 클래스는 중복 사용을 해결하고, 동시에 효율적으로 사용하기 위해 **상속** 통해 새로운 클래스를 만들 수도 있다.



* **함수형 언어란 무엇인가? ( 2가지 )** []
  * 순수 함수(Pure Function)를 순서대로 조합하고 프로그램을 방식을 말한다.
  * 함수형 프로그래밍은 수학의 함수에 충실해서 대부분 '반환형'이 존재한다.



* **함수형 언어와 절차적 언어의 데이터 관리에 대한 차이점은 무엇인가? ** [12]
  * 함수형 언어는 절차적 언어처럼 함수가 있다.
  * 절차적 언어 : 동일 한 데이터를 업데이트 할 시 '덮어쓰기'를 통해 상태를 변화 시킨다.
  * 함수형 언어 : 동일 한 데이터를 업데이트 할 시 새로운 줄을 추가하고 '누적' 시켜 이전 상태가 사라지지는 않다. ( 불변성(immutable) )



* **함수형 언어가 유용할 때는 언제인가?** [12]
  * <u>**여러 개의 프로그램이 데이터에 접근할 때 사용한다.**</u>
  * 특정 분야에 필요하다. ( 가장 안 쓰이는 패러다임이기도 하다. )
    - 데이터 쪽에서 많이 사용된다.



* **선언형 프로그래밍과 명령형 프로그래밍 언어를 비교해보자.** [1]

  * 선언형 프로그래밍 ( declarative programming )

    * 함수형 프로그래밍은 선언형 프로그래밍 패러다임을 따른다.
    * '선언형 프로그래밍'은 프로그래밍이 문이 아닌 식이나 선언으로 수행된다. 

  * 명령형 프로그래밍 (  imperative programming )

    * 선언형 프로그래밍과 비교 되는데, ''명령형 프로그래밍''은 상태를 바꾸는 것(원하는 결과 값에 도달하기 위한 과정을 나열한다.)을 강조한다. 
      ( 우리가 주로 작성하는 방식이다. )

      반면, 함수형 프로그래밍은 함수의 응용을 강조한다. 

    * 모든 선언형 코드는 명령코드 위에 쓰여진다.







## 02. 언어별 분류 [ 생략 ]

( 문제집 생략 )





## 03. 프로그래밍 구문



### 1. 프로그래밍 언어

#### 1.1. 프로그래밍과 문장

* **문장, 리터럴, 프로그램, 표현식을 크기 순으로 나열하시오.** []
  * 리터럴 < 표현식 < 문장 < 프로그램





* **리트럴이 의미하는 2가지는 무엇인가?** []

  1. 표현식

     * 고정된 값을 나타내는 표기법이다. 

     * 객체 지향 언어에서는 객체의 리터럴 표기법을 지원한다.

       ```c#
       int num1 = 0xF3;		// 16진수 표기법
       int num2 = 0b01;		// 2진수 표기법
       ```

       ```javascript
       var obj = { name: 'SY', age: 50 }; // 객체리터럴 방식으로 만든 객체
       ```

  2. 매직넘버 / 데이터(값)

     * **변수에 넣는 변하지 않는 데이터(값) 그 자체**를 뜻한다.

       ```c#
       const int num = 1; 		// num은 상수이고, 1은 리트럴이 되는 것이다.
       ```





* **표현식이란 무엇인가?**

  **하나의 값으로 계산될 수 있는** 리터럴, 변수, 연산자, 함수 호출 등의 **조합**을 의미합니다.  

  표현식을 실행하며 **평가(evaluate)** 되며, 어떤 값을 **반환** 한다.





* **문장 / 구문 ( statement )는 무엇인가?**

  표현식이 하나 이상 모여서 **실행할 수 있는 코드의 최소 단위**가 된다. 

  보통 세미콜론, 중괄호{} 블록, 들여쓰기 등을 통해 구분된다.





* **프로그램이란 무엇인가?**

  문장(statement)이 모여서 완성된 어떤 행동의 수행 순서이다.

  



* **세미콜론 / 블록 / 들여쓰기 / 주석을 영어로 서술하시오.**
  * Semicolon
  * Block
  * Indentation
  * Comment : 컴파일 할 때 무시되는 문장 ( Comment out )





#### 1.2. 네이밍 규칙



* **네이밍 규칙에 중요한 3가지는 무엇인가?**
  * 키워드 (keyword)
  * 식별자 (identifier)
  * 코딩 컨벤션



* **키워드란 무엇인가?**

  프로그래밍 언어마다 특별한 의미가 부여된 단어로, 이미 사용하던 예약어다.

  언어마다 키워드를 확인하는 방법이 있기도 하다.



* **식별자란 무엇인가?**

  * 프로그래밍 언어에서 임의로 이름을 붙여 사용하는 단어이다.

    (ex) 변수명, 함수명, 클래스명 등

  * 언어마다 자체적으로 강제하는 규칙으로 언어마다 약간의 차이가 있을 수 있다.



* **코딩 컨벤션이란 무엇인가?**
  * 코드를 작성할 때 지켜야 할 규칙들을 말한다.







# ==========================





## == 중간고사 ==

## 04 프로젝트 빌드와 컴파일 ( + 에러 )

( ※ 미입력 - 빈 프로젝트 실행 방법 필기 이후에 진행하기 )











## 05. 변수와 상수 ( 데이터 타입 )



### 1. 변수와 상수

#### 1.1. 변수

**선언과 대입은 무엇인가?**

* 선언 : 컴퓨터에 이름 알리기
* 대입 : 컴퓨터에 실제 값 알리기



**변수를 사용하는 이유?**

1. 재사용
2. 명확한 의도 파악



**상수( 매직넘버 )를 사용하면 안되는 이유?**

1. 재사용 불가
2. 명확한 의도 파악 불가능

```c#
/* 매직넘버 예시 */
Console.WriteLine(30);			// int 
Console.WriteLine(30.1);		// double
Console.WriteLine(30.2f);		// float
Console.WriteLine(true);		// bool
Console.WriteLine('p');			// char
```





---



#### 1.2. 상수

**상수-변수 사용 시 주의 할 점 - 3가지?**

1. const 키워드 사용
2. 선언과 대입 동시에 사용
3. const 상수 변수 값 변경 ( 컴파일 에러 발생 )

```c#
const int INDEX = 0;
INDEX = 2;	// error
```



**접두사 접미사를 사용하는 이유**

1. 문자 10의 다양한 의미 
   * 컴퓨터 입장에서 문자 10은 다양한 의미를 표현하기 때문에 알아 듣기 어렵다. 
     ( int 10 / double 10  /2진법 10)
2. 가독성 향상
   * 접두사 접미사의 사용은 명확한 의도를 전달하여 가독성을 높여준다.



**상수 접두사는 대표적인 게 어떤 것이 있고, 주로 어떤 형태로 사용하는가?**

* 0b : 2진수 값 표기
* 0x : 16진수 값 표기

* 소문자를 주로 사용하며, 대문자는 거의 쓰이지 않는다. 

```c#
int num1 = 0b10;	// 사용 비중이 매우 높다.
int num3 = 0x10;	// 사용 비중이 매우 높다.
```



**상수 접미사는 대표적인 게 어떤 것이 있고, 주로 어떤 형태로 사용하는가?**

* -u
* -l
* -f
* double형 접미사( -d )도 있지만 잘 쓰이는 편은 아니다.
* 소문자를 주로 사용하며, 대문자는 거의 쓰이지 않는다. 



**상수 접미사는 어떨 때 사용하는 게 좋은가?**

수정이나 대입 할 때 접미사를 붙여 주는 게 특히 좋습니다. 

왜냐하면 변수 선언문에는 왼쪽에 바로 type이 보이지만 단순 대입문에서는 변수 타입이 안 보인다. 
이럴 때 접미사를 붙여주면 곧바로 변수 타입을 알 수 있어서 ( 프로그래머가 눈으로 봤을 때 ) 가독성이 올라가기 때문이다.







### 2. 기본 자료형 

**기본 자료형 ( Primitive Types ) 이란?**

* 하드웨어에서 직접적으로 이해하는 자료형
* 컴퓨터가 이해할 수 있는 가장 자연스러운 형태의 데이터
* 원시 자료형, 가장 단순한 형태의 자료형, Built-in Types 등 다양하게 불리기도 한다.





**데이터의 최대 조합수는?**

2의 비트 제곱수 개

![image-20230626002403688](./assets/image-20230626002403688.png)



**기본 자료형 종류는?**

* 정수형 ( Integer Types ) 
  * 음수, 0, 자연수를 의미한다.
  * byte, short, int, long

    * byte : 8비트 ( 1 바이트 )
    * short : 16비트 ( 2 바이트 )
    * int : 32비트 ( 4 바이트 )
    * long : 64비트 ( 8 바이트 )
  * [참고] C#에서 byte가 다른 언어에서는 char 형으로 쓰이는 편이다.

* 부동소수점형 ( Floating-Point Types )
  * 소수점이 있는 수이다.
  * float, double
    * float : 32비트 ( 4 바이트 )
    * double : 64비트 ( 8 바이트 )

* 문자형 ( Character Type )
  * 하나의 문자를 담는 자료형
  * char : 16비트 ( 2바이트 ) 
    * 유니코드
* 불리언형 ( Boolean Type )
  * true, false를 표현하는 자료형 ( [주의!] 소문자 )
  * bool : 1바이트



**실무에서 기본적으로 많이 쓰이는 자료형은 무엇인가?**

* int와 float으로 4바이트 형이다.
* 그 이유는 일반적인 CPU의 구조 때문에 4바이트 크기의 데이터로 연산을 하는 것이 가장 빠르기 때문입니다. 
  ( 순수하게 CPU의 연산장치만 고려할 경우를 말한다. ) 
* 하지만 정말 메모리가 많이 모자란 시스템에서 프로그래밍을 한다면 이 마저도 byte로 줄여서 메모리를 최대로 아끼려고 합니다. 



**signed와 unsigned 형이 없는 자료형은?**

문자형, 실수형, 불리언형

* char
* float
* double
* bool



**데이터 타입 중 unsigned가 기본형인 자료형은 무엇인가?**

* byte ( C# char형 대신 )
  * sbyte : 부호를 사용하고 싶을 때는 이렇게 사용한다.



**데이터 형에서 양수와 음수 갯수 차이는?**

* 음수가 1개 더 많다. 양수는 보통 0부분을 대신 가지고 있다.



**[ C : char ]와 [ C# : byte ], [ C# : char ]의 차이점은?**

* C : char
  * 8비트 ( 1 바이트 )
  * ASCII 문자 체계
  * [범위] 양수 음수 사용
* C# : byte
  * 8비트 ( 1 바이트 )
  * C : char형 계승
  * unsigned가 기본형이다.
  * sbyte / byte - 두 가지를 사용한다.
* C# : char
  * 16비트 ( 2 바이트 )
  * 유니코드
  * [범위] U+0000~U+FFFF



**아래 보이는 2진수는 int형이다 예상 되는 값은 무엇인가?**

* 01111111111111111111111111111111 : int.MAX

* 10000000000000000000000000000000 : int.MIN

* 11111111111111111111111111111111 : -1

  * 0b0111_1111_1111_1111_1111_1111_1111_1111;
  * 0b1000_0000_0000_0000_0000_0000_0000_0000;

  * 0b1111_1111_1111_1111_1111_1111_1111_1111;







### 3. 형 변환

**묵시적 형변환이란 무엇인가?**

컴파일러에서 기본 자료형 간의 변환을 자동으로 해주는 것을 말한다.

```C#
int num1 = 10000;
long num2 = num1;
```





**묵시적 형변환의 우선순위는?**

* 현재 형보다 더 큰 형으로 변할 수 있다.
  * [주의!] usigned는 상위 데이터 형의 usignend 형으로 변할 수 있다.

* 정수 형은 실수 형이 으로 변할 수 있다.





**정밀도 손실은 언제 날 가능성이 큰가?**

* int / long => float
* long => double
* 큰 형에서 작은 형으로 변환
* [참고] 언어마다 손실 상황을 고려해서 컴파일 오류를 내는 경우도 있다.

```c#
using System;

namespace SampleProject
{
    class Program
    {
        static void Main(string[] args)
        {
            int num1 = 1234567890;
            float num2 = num1;
            
            Console.WriteLine(num1 - (int)num2);
        }
    }
}
```

```
-46
```

상식적으로 0이 나오는 것이 정상이지만 이렇게 정밀도 문제가 생긴다.

그러니 int로 표현 가능 한 것은 int로 사용하는 것이 좋다. 





**승격이란?**

* 연산 시 자료형의 크기가 더 큰 것을(표형범위가 넓은 형식) 따르는 것이다.
* 연산자가 더 효율적으로 돌 수 있게 만드는 것이다.

```C#
double num1 = 3.7;
int num2 = 10;

Console.WriteLine(num1 + num2);		// 13.7 출력 ( 승격 )
```





**Type Conversion과 Type Promotion 차이는?**

딱히 알 필요 없다.
엄밀히 따르면 다른 거지만 프로그래머에게 이 두 개의 차이점을 알아야 하는 경우는 드물다. 





**명시적 변환이란?**

* 프로그래머가 의도를 가지고 형 변환을 시키는 것이다.

* 소괄호 ( () )를 이용하여 변하고자 하는 자료형을 보여준다.





**명시적 형 변환 시 주의사항 3가지는?**

* 큰 자료형에서 작은 자료형으로 형 변환시 앞부분은 잘라내고 뒷 부분 숫자만 가져 온다.

  ```c#
  long num1 = 9223372036854775807;
  int num2 = (int)num1;			// -1
  ```

  ![image-20230705121515013](./assets/image-20230705121515013.png)

* 실수에서 정수로의 명시적 형 변환은 무조건 내림이 된다. ( 소수점 없애기 )

  ```c#
  long num1 = 9223372036854775807;
  int num2 = (int)num1;			// -1
  
  double num3 = 10.9;
  int num4 = (int)num3;			// 10
  ```

* 모든 자료형이 변환이 되는 것은 아니다.

  ```c#
  long num1 = 9223372036854775807;
  bool bBool = (bool)num1;		// 컴파일 오류
  ```











## 08. 연산자



**비트연산자**

^   (xor) 



**논리연산자**

**! ( a == b || c == d )**

* ( a != b && c != d )



**조건연산자**

```c#
int max = (num1 > num2) ? num1 : num2
```



**우선순위**

단항 => 사칙연산 => 쉬프트 => 비교 연산자 => 같음 연산자 => 비트 연산 => 논리 연산 => 조건연산 ( 삼항연산 ) => 대입



**평가순서**

**a || b && c**
a가 참 일때는 b와 c를  평가하지 않음
a가 거짓이고 b가 참이면 c를 평가함
a가 거짓이고 b가 거짓이면 c를 평가하지 않음

**a && b || c**
a는 거짓 일때 b는 평가하지 않고 c는 평가를 하게 됨
a가 참이고 b가 참일때 c는 평가하지 않음
a가 참이고 b가 거짓일때 c를 평가함





**컴파일 에러**

* ~= : 이런 연산자는 없다.







## 10. 조건문

### if / else if / else

**else if 문**

* else if문에 <u>내재 된 조건</u>은 **앞에 조건문들이 거짓이라는 것이 포함**된다.  ( + 중복 코드에 주의하자. )



**컴파일 에러**

* if문 없이 혼자 else문 작성 시 - 컴파일 에러 발생





### switch

```C#
switch (menu)
{
	case 1:
		...
		break;
	case 2:
		...
		break;
	default:
		...
		break;
}
```



**case { body }**

* body에 아무런 코드가 없다면 break문 없이도 컴파일러 가능
* body에 추가로 코드가 있다면 break문 없으면 컴파일 error









## 13. 입출력1 (String)

### 문자열

* \\\\
  * \\"
  * \\'
* \\x : 16진수 아스키값 출력

* \+ 더하기 연산자
* == 연산자

---



### 입력



**-Parse**

* 공백을 제외한 데이터를 해석한다.

**코드**

```c#
int num1 = int.Parse(Console.ReadLine());
long num2 = long.Parse(Console.ReadLine());
Console.WriteLine(num1);
Console.WriteLine(num2);
```

**실행**

```c#
     25     // int.Parse(Console.ReadLine())
  9999999   // long.Parse(Console.ReadLine())
```

```c#
25			// num1 = 25
9999999		// num2 = 9999999
```





### 출력

2진수로 변환 출력

```c#
Console.WriteLine(byte1 + " -> " + Convert.ToString(byte1, 2));
```



### 에러

**컴파일 에러**

```c#
int num = Console.ReadLine();	// 묵시적 변환 ( 불가능 )
int num = (int)Console.ReadLine();	// 명시적 변환 ( 불가능 )
```



**런타임 에러**

```c#
int result = int.Parse("a");
```





```c#
int rowCount = data.GetLength(0);
int colCount = data.GetLength(1);
```

```c#
string octNumber = Convert.ToString(numbers[i], 8);
output.Write(octNumber.PadLeft(width, ' '));
```

