# 05 연산식

* [연산자 우선순위표](https://docs.python.org/3/reference/expressions.html#operator-precedence)

| 우선순위 | 연산자                                          | 설명                                                 |
| -------- | ----------------------------------------------- | ---------------------------------------------------- |
| 1        | (값...), [값...], {키: 값...}, {값...}          | 튜플, 리스트, 딕셔너리, 세트 생성                    |
| 2        | x[인덱스], x[인덱스:인덱스], x(인수...), x.속성 | 리스트(튜플) 첨자, 슬라이싱, 함수 호출, 속성 참조    |
| 3        | await x                                         | await 표현식                                         |
| 4        | **                                              | 거듭제곱                                             |
| 5        | +x, -x, ~x                                      | 단항 덧셈(양의 부호), 단항 뺄셈(음의 부호), 비트 NOT |
| 6        | *, @, /, //, %                                  | 곱셈, 행렬 곱셈, 나눗셈, 버림 나눗셈, 나머지         |
| 7        | +, -                                            | 덧셈, 뺄셈                                           |
| 8        | <<, >>                                          | 비트 시프트                                          |
| 9        | &                                               | 비트 AND                                             |
| 10       | ^                                               | 비트 XOR                                             |
| 11       | \|                                              | 비트 OR                                              |
| 12       | in, not in, is, is not, <, <=, >, >=, !=, ==    | 포함 연산자, 객체 비교 연산자, 비교 연산자           |
| 13       | not x                                           | 논리 NOT                                             |
| 14       | and                                             | 논리 AND                                             |
| 15       | or                                              | 논리 OR                                              |
| 16       | if else                                         | 조건부 표현식                                        |
| 17       | lambda                                          | 람다 표현식                                          |
| 18       | :=                                              | 할당 표현식                                          |





## 1. 변환 ( cast ) 

type cating

```python
string_number = input("입력A> ")

int_a = int(string_number)			#int cast
print(type(int_a))

float_a = float(string_number)		#float cast
print(type(float_a))

string_a = str(int_a)				#string cast
print(type(string_a))
```

> **[ ValueError 예외 ]**
>
> 자료형을 변환할 때 '변환할 수 없는 것'을 변환 하려고 하면 ValueError 예외가 발생한다.
>
> ```python
> int("안녕하세요")
> int("5.245")
> float("안녕하세요")
> ```







## 2. 산술연산

**산술 연산자**

| 연산자 | 기능                        | 문법    | 설명                                                  |
| ------ | --------------------------- | ------- | ----------------------------------------------------- |
| +      | 덧셈                        | a + b   | 두 값을 더함                                          |
| -      | 뺄셈                        | a - b   | a에서 b를 뺌                                          |
| *      | 곱셈                        | a * b   | 두 값을 곱함                                          |
| /      | 나눗셈                      | a / b   | a에서 b를 나누며 결과는 실수                          |
| //     | 버림 나눗셈(floor division) | a // b  | a에서 b를 나누며 소수점 이하는 버림                   |
| %      | 나머지                      | a % b   | a에서 b를 나누었을 때 나머지를 구함                   |
| **     | 거듭제곱                    | a ** b  | a를 b번 곱함                                          |
| @      | 행렬 곱셈                   | a @ b   | 행렬 a와 b를 곱함                                     |
| +      | 양수 부호                   | +a      | a에 양수 부호를 붙임                                  |
| -      | 음수 부호                   | -a      | a에 음수 부호를 붙임                                  |
| +=     | 덧셈 후 할당                | a += b  | a와 b를 더한 후 결과를 a에 할당                       |
| -=     | 뺄셈 후 할당                | a -= b  | a에서 b를 뺀 후 결과를 a에 할당                       |
| *=     | 곱셈 후 할당                | a *= b  | a와 b를 곱한 후 결과를 a에 할당                       |
| /=     | 나눗셈 후 할당              | a /= b  | a에서 b를 나눈 후 결과를 a에 할당(결과는 실수)        |
| //=    | 버림 나눗셈 후 할당         | a //= b | a에서 b를 나눈 후 결과를 a에 할당(소수점 이하는 버림) |
| %=     | 나머지 연산 후 할당         | a %= b  | a에서 b를 나누었을 때 나머지를 구하여 a에 할당        |
| **=    | 거듭제곱 후 할당            | a **= b | a를 b번 곱한 후 결과를 a에 할당                       |
| @=     | 행렬 곱셈 후 할당           | a @= b  | 행렬 a와 b를 곱한 후 결과를 a에 할당                  |





### 2.1. 사칙연산 ( + - * /)

* **덧셈 : +**
* **뺄셈 : -**
* **곱셈 : ***
* **나눗셈 : /**
  * `/` 연산시에는 결과가 정수값이더라도 항상 결과가 실수 형태로 나오게 된다.
  * 정수 결과를 얻어야 하는 경우라면, 꼭 `int()`를 이용하여 type을 정수형인 int로 변경해줘야 한다.
    ( 아니면 `//` 를 사용하면 된다.)


---

> **[ 우선순위 ]**
>
> 1. 곱셈과 나눗셈을 먼저 계산한다. 
>
> 2. 같은 우선순위를 가지는 연산자는 왼쪽에서 오른쪽 순서로 계산합니다. 
>
>    해결 : 연산자의 우선순위가 헷갈리면 괄호를 부여하여 사용한다.

---

> **[ TypeError ]**
>
> 서로 다른 자료를 연산하면 예외가 발생한다.

---

> **[ 부동소수점 연산 - 한계 ]**
>
> 부동수점 연산의 주의점  - 컴퓨터의 한계로 정확하지 않다.
>
> ```python
> >>> print(0.1 + 0.2)
> 0.30000000000000004
> ```

---

> **ZeroDivisionError**: division by zero
>
> ```python
> 1 / 0
> ```
>
> 0으로 나누기를 할 경우 발생





### 2.2. 정수 나누기 ( // )

( // ) : 숫자를 나누고 소수점 이하의 자릿수를 떼어 버린 후, 정수만 남긴다.

```python
>>> print("3 / 2 = ", 3/2)
3 / 2 =  1.5
>>> print("3 // 2 = ", 3//2)
3 // 2 =  1
>>> print("3 // 2.0 = ", 3//2.0)
3 // 2.0 = 1.0
```

[참고] 연산과 자료형 자동 변환

**+, -, *, // 등**  

int와 float가 섞여 있으면 최종적으로 float으로 계산한다.







### 2.3. 나머지 연산 ( % )

A를 B로 나누었을 대 남은 나머지를 구하는 연산자입니다.

```python
>>> print("5%2=", 5%2)
5%2=1
```

음수로도 나머지 연산이 가능하다.



[보충] 파이썬의 나머지 연산은 C언어의 나머지 연산과 다릅니다. 
예를 들어서 C언어에서 ```-3 % 26```의 결과는 ```-3``` 입니다. 파이썬에서는 나머지 연산자 왼쪽의 수가 음수일 경우 ```(-3 + 26) % 26```와 같이 나머지 연산의 결과가 항상 양수가 나오도록 바꿔서 계산합니다.

```
>>> -3 % 26
23
```







### 2.4. 거듭제곱 연산 ( ** )

```python
>>> print("5**2=", 5**2)
5**2=25

>>> print("루트4 : ", 4**(1/2))     # 제곱근 응용
루트4 : 2
```





### 2.5. 행렬 곱셈 연산 ( @ )

행렬 곱셈 연산자는 파이썬 3.5이상부터 사용할 수 있으며 numpy 모듈을 설치해야 합니다(pip install numpy).

```python
>>> import numpy as np    # numpy 모듈을 가져옴
>>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])    # 3x3 행렬 생성
>>> b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])    # 3x3 행렬 생성
>>> a @ b    # 행렬 곱셈
array([[ 30,  36,  42],
       [ 66,  81,  96],
       [102, 126, 150]])
```







## 3. 복합 대입 연산자

### 3.1. 숫자

* **+=**
* **-=**
* ***=**
* **/=**
* **//=**
* **%=**
* **= 



### 3.2. 문자열

* += : 문자열 연결 후 대입
* *= : 문자열 반복 후 대입







## 4. 비교연산 / 논리연산

### 4.1. 비교연산자

[비교연산 공식문서](https://docs.python.org/3/reference/expressions.html#comparisons)



#### 1) 비교 연산 ( 값 )

이번에는 조건문에 비교연산자(`<`, `>`, `==`, `!=`, `>=`, `<=`)를 쓰는 방법에 대해 알아보자.

다음 표는 비교 연산자를 잘 설명해 준다.

| 비교연산자 | 설명                  |
| :--------- | :-------------------- |
| x < y      | x가 y보다 작다        |
| x > y      | x가 y보다 크다        |
| x == y     | x와 y가 같다          |
| x != y     | x와 y가 같지 않다     |
| x >= y     | x가 y보다 크거나 같다 |
| x <= y     | x가 y보다 작거나 같다 |



**범위 구하기** 

파이썬은 다음과 같은 코드를 사용해 변수의 범위 등도 비교할 수 있다. 

* print( 10 < x < 30 )

```python
>>> x = 25
>>> print( 10 < x < 30 )
True
>>> print( 40 < x < 60 )
False
```





#### 2) in, not in - Membership test operations

**in, not in**

비교 연산자안의 Membership test operations다. 

컨테이너와 함께 사용된다.

[주의!] 컨테이너 외의 값 사용시 TypeError 발생할 수 있다.

- https://docs.python.org/3/reference/expressions.html#membership-test-operations

| in          | not in          |
| :---------- | :-------------- |
| x in 리스트 | x not in 리스트 |
| x in 튜플   | x not in 튜플   |
| x in 문자열 | x not in 문자열 |

영어 단어 in의 뜻이 "~안에"라는 것을 생각해 보면 다음 예가 쉽게 이해될 것이다.

내부에 특정 값이 있는 없는지 확인하는 연산이다.

 

**1. 문자열(strings)**

```python
########### in ###########

if 'p' in 'python':
    print(True)
else:
    print(False)
-------------------------
True


########### not in ###########

if 'k' not in 'python':
    print(True)
else:
    print(False)
-------------------------
True
```

---

```python
# 문자열과 함께 사용하기
for i in "안녕하세요?":
    print(i)
```

```
안
녕
하
세
요
?
```

---

```python
# end가 빈 문자열일 경우
for i in "안녕하세요?":
    print(i, end="")
```

```
안녕하세요?
```

---





**2. 리스트(list)**

```python
############## in ##############

if 'a' in ['a','b','c']:
    print(True)
else:
    print(False)
--------------------------------
True

############## not in ##############
if 'd' not in ['a','b','c']:
    print(True)
else:
    print(False)
--------------------------------
True
```

 

**3. 튜플(tuple)**

```python
############# in #############
if 'a' in ('a','b','c'):
	print(True)
else:
	print(False)
-------------------------
True

############# not in #############
if 'd' not in ('a','b','c'):
	print(True)
else:
	print(False)
-------------------------
True
```



**4. 딕셔너리(Dictionary)**

```python
########### in ###########

if 'a' in {'a':1,'b':2}:
	print(True)
else:
	print(False)
---------------------------
True


########### not in ###########

if 'c' not in {'a':1,'b':2}:
	print(True)
else:
	print(False)
---------------------------
False
```





#### 3) 식별 연산자 - Identity comparisons

객체를 비교한다.

is, is not도 같다, 다르다 이다.

* **is ** 
* **is not**



**[ 식별연산자 ( is )와 비교연산자 ( == ) - 차이점 ]** 

* 비교연산자 ( ==, != ) : Value(값)를 비교한다. 

* 식별연산자 ( is, is not ) : Object(객체)를 비교한다.

```python
>>> 1 == 1.0
True
>>> 1 is 1.0
False
>>> 1 is not 1.0
True
```

1과 1.0은 정수와 실수라는 차이점이 있지만 값은 같습니다. 따라서 ==로 비교해보면 True가 나옵니다. 
하지만 1과 1.0을 is로 비교해보면 False가 나옵니다. 

왜냐하면 1은 정수 객체, 1.0은 실수 객체이므로 두 객체는 서로 다르기 때문입니다.

---

**[주의!]** 컨테이너 선언시 값이 같더라도 서로 다른 객체를 생성한다. ( 나의 추측 )

```python
a = [10, 20, 30, 15, 20, 40]
b = [10, 20, 30, 15, 20, 40]
c = a

print("=================================")
print("a :", a)
print("b :", b)
print("c :", c)
print("=================================")
print("id(a) :", id(a))
print("id(b) :", id(b))
print("id(c) :", id(c))
print("=================================")
print("a is b :", a is b)
print("a is c :", a is c)
print("=================================")
```

```
=================================
a : [10, 20, 30, 15, 20, 40]
b : [10, 20, 30, 15, 20, 40]
c : [10, 20, 30, 15, 20, 40]
=================================
id(a) : 3065273178048
id(b) : 3065273653440
id(c) : 3065273178048
=================================
a is b : False
a is c : True
=================================
```

c = a와 같이 리스트를 다른 변수에 할당하면 리스트는 2 개가 될 것 같지만 실제로는 리스트가 1 개 입니다.

---





**주의! |** **값 비교에 is를 쓰지 않기**

값을 비교할 때는 is를 사용하면 안 됩니다. 다음과 같이 변수 a에 -5를 할당한 뒤 a is -5를 실행하면 True가 나오지만 다시 -6을 할당한 뒤 a is -6을 실행하면 False가 나옵니다.

```
>>> a = -5
>>> a is -5
True
>>> a = -6
>>> a is -6
False
```

왜냐하면 변수 a가 있는 상태에서 다른 값을 할당하면 메모리 주소가 달라질 수 있기 때문입니다. 따라서 다른 객체가 되므로 값이 같더라도 is로 비교하면 False가 나옵니다. 

값(숫자)를 비교할 때는 is가 아닌 비교 연산자를 사용해야 합니다.









### 4.2. 논리연산

* **and, or, not**

조건을 판단하기 위해 사용하는 다른 연산자로는 and, or, not이 있다. 각각의 연산자는 다음처럼 동작한다.

| 연산자  | 설명                                         |
| :------ | :------------------------------------------- |
| x or y  | 또는  -  x와 y 둘중에 하나만 참이어도 참이다 |
| x and y | 그리고  -  x와 y 모두 참이어야 참이다        |
| not x   | 아니다  -  x가 거짓이면 참이다               |

3개의 조건을 모두 만족시키는지에 대한 여부 역시 and를 2번 사용하여 표현할 수 있습니다. 
조건이 더 많아도 됩니다.

```python
if 조건1 and 조건2 and 조건3:
    코드1
```



#### 1) and, or ( 이항연산자 )

```python
>>> money = 2000
>>> card = True
>>> if money >= 3000 or card:
...     print("택시를 타고 가라")
... else:
...     print("걸어가라")
...
택시를 타고 가라
>>>
```

> **[ 단항연산자 / 이항연산자 ]**
>
> * 단항연산자 : 피연산자가 1개 ( +10, not ) 
> * 이항연산자 : 피연산자가 2개 ( 10 + 10, 10 - 10, 10 * 10 )



##### (1) 혼합 사용

```python
a = int(input())

if a % 2 == 0 or (a % 2 == 1 and a >= 10):
    print("special")
else:
    print("normal")
```



##### (2) and, or 연산자 우선순위

소괄호를 사용하지 않으면 어떻게 될까요?

```python
if a % 2 == 0 and a % 5 == 0 or a % 7 == 0:
    코드1
```

and는 or 보다 연산자 우선순위가 높기 때문에, 먼저 식을 계산하게 되므로 다음 코드와 정확히 동일하게 동작하게 됩니다.

```python
if (a % 2 == 0 and a % 5 == 0) or a % 7 == 0:
    코드1
```



**python3 코드**

```python
a = int(input())

if a % 2 == 0 and a % 5 == 0 or a % 7 == 0:
    print("special")
else:
    print("normal")
```

**출력결과 1**

```
>> 10

special
```

**출력결과 2**

```
>> 21

special
```



##### (3) 연쇄 비교 (Chained Comparison) 연산자

and를 사용한 표현식을 더 간결하게 줄일 수 있습니다.

```python
# 예시) a가 1보다 크고 3보다 작은가?
a = 3

1 < a and a < 3
1 < a < 3  # and를 사용한 것보다 간결
```

```python
a, b, c = 1, 2, 3

# 예시) 임의의 a, b, c에 대해서 a가 b보다도 크고 c보다도 큰가?

b < a and a > c
b < a > c  # and를 사용한 것보다 간결
```







#### **2) not  ( 단항연산자 )**

```python
# not 연산자 ( 단항연산자 )
>>> print(not True)
False
>>> print(not False)
True
```

```python
x = 10
under_20 = x < 20  # under_20 = (x < 20)
print("under_20:", under_20)
print("not under_20:", not under_20)
```





#### 3) **단락 평가**

논리 연산에서 중요한 부분이 단락 평가(short-circuit evalution)입니다. 단락 평가는 첫 번째 값 만으로 결과가 확실할 때 두 번째 값은 확인(평가)하지 않는 방법을 말합니다. 즉, and 연산자는 두 값이 모두 참이라야 참이므로 첫 번째 값이 거짓이면 두 번째 값은 확인하지 않고 바로 거짓으로 결정합니다.

```
# 첫 번째 값이 거짓이므로 두 번째 값은 확인하지 않고 거짓으로 결정
print(False and True)     # False
print(False and False)    # False
```

or 연산자는 두 값 중 하나만 참이라도 참이므로 첫 번째 값이 참이면 두 번째 값은 확인하지 않고 바로 참으로 결정합니다.

```
# 첫 번째 값이 참이므로 두 번째 값은 확인하지 않고 참으로 결정
print(True or True)     # True
print(True or False)    # True
```

특히 파이썬에서 논리 연산자는 이 단락 평가에 따라 반환하는 값이 결정됩니다. 



##### (1) and

True, False를 논리 연산자로 확인하면 True, False가 나왔는데, True and 'Python'의 결과는 무엇이 나올까요?

```
>>> True and 'Python'
'Python'
```

문자열 'Python'도 불로 따지면 True라서 True and True가 되어 True가 나올 것 같지만 'Python'이 나왔습니다. 왜냐하면 파이썬에서 논리 연산자는 마지막으로 단락 평가를 실시한 값을 그대로 반환하기 때문입니다. 따라서 논리 연산자는 무조건 불을 반환하지 않습니다.

다음과 같이 마지막으로 단락 평가를 실시한 값이 불이면 불을 반환하게 됩니다.

```
>>> 'Python' and True
True
>>> 'Python' and False
False
```

여기서는 문자열 'Python'을 True로 쳐서 and 연산자가 두 번째 값까지 확인하므로 두 번째 값이 반환됩니다. 만약 다음과 같이 and 연산자 앞에 False나 False로 치는 값이 와서 첫 번째 값 만으로 결과가 결정 나는 경우에는 첫 번째 값이 반환됩니다.

```
>>> False and 'Python'
False
>>> 0 and 'Python'    # 0은 False이므로 and 연산자는 두 번째 값을 평가하지 않음
0
```



##### (2) or

or 연산자도 마찬가지로 마지막으로 단락 평가를 실시한 값이 반환됩니다. 다음은 or 연산자에서 첫 번째 값만으로 결과가 결정되므로 첫 번째 값이 반환됩니다.

```
>>> True or 'Python'
True
>>> 'Python' or True
'Python'
```

만약 두 번째 값까지 판단해야 한다면 두 번째 값이 반환됩니다.

```
>>> False or 'Python'
'Python'
>>> 0 or False
False
```







## 5. 비트연산

* 비트시프트연산

  <<, >> 

* 비트단위 논리연산

  &  - 비트 AND

  ^  - 비트 XOR

  |  - 비트 OR









## 6. 조건부 표현식 ( 삼항 연산자 )

파이썬식 3항연사자로 사용되고 있다. ( 공식문서 자세히 읽어볼 필요가 있다. )

파이썬의 조건부 표현식(conditional expression)을 사용하면 위 코드를 다음과 같이 간단히 표현할 수 있다.

```python
# 기존 코드

if 조건:
    a = v1
else:
    a = v2
```

```python
# 삼항 코드 

a = v1 if 조건문 else v2
```

조건부 표현식은 다음과 같이 정의한다.

`변수` = `조건문이_참인_경우의_값` if `조건문` else `조건문이_거짓인_경우의_값`

조건부 표현식은 가독성에 유리하고 한 줄로 작성할 수 있어 활용성이 좋다

---

```python
# python3 코드

n = 8
a = 2 + 6 + (5 if n > 10 else 6)
print(a)
```

```python
# 출력결과

14
```







## 7. 대입 표현식 연산자

( 파이썬 3.8에 새로 추가되었습니다. )

* **대입 표현식 연산자 ( assignment expression )**
* **바다코끼리 연산자 ( Walrus Operator )**
* **or ( named expression )**



while문을 효율적으로 사용할 수 있게 하는 연산자이다.

변수에 값을 대입함과 동시에 표현식으로도 사용될 수가 있다는 특징을 가지고 있습니다. 
그래서 **<u>대입 표현식(assignment expression) 연산자</u>**라고 부릅니다. 

```:=``` 연산자가 [바다코끼리(Walrus)](https://en.wikipedia.org/wiki/Walrus)를 닮았다고 합니다.

```python
# 대입만 하고 표현식으로 사용할 수가 없습니다.
# 즉, 이 문장 자체로는 '값'이 없습니다.
word = "헬로우"
```

```python
# 대입과 동시에 그 자체를 '값'으로 사용할 수 있습니다.
(word := "Hello")
```

```
'Hello'
```



먼저 바다코끼리 연산자를 사용하지 않은 코드를 봅시다.

```python
while True:
    word = input()
    if word == "종료":
        break
    print(word)
```

이때 바다코끼리 연산자를 사용하면 훨씬 간결하게 만들 수 있습니다. 
```for```문의 ```대상```(target)과 비슷하게 입력받은 단어를 변수에 담을 수 있기 때문입니다.

```python
while (word := input()) != "종료":
    print(word)
```

**[주의!]  ```:=``` 연산자의 우선순위가 낮기 때문에 괄호가 필요합니다.**





## 8. 종합 훈련

