# 15 재귀 함수, 랜덤



## 1. 재귀 함수

* **재귀함수는 어떤 개념으로 봐야하나?**  123
  * 재귀 함수는 일부를 추상화를 한 개념이다.

  * 수학적으로 말하면 일반화이다.




* **재귀함수의 마인드는 무엇인가?** 123
  
  * 작은 문제 해결 방식을 활용하여 더 큰 문제를 해결한 다는 마인드로 접근한다.
  
    

* **재귀 함수의 구성 요소 2가지를 말하시오.** 123
  * 종료 조건
  * 재귀적 함수 호출
    * 함수의 인자를 바꿔 스스로를 다시 호출
    * 이 때, 함수의 인자는 현재 문제보다 작은 문제를 대표해야 한다.

    * 즉, 동일한 동작을 보다 작은 문제에 적용
      ( 너가 해결해줘 토스 호출 => 호출 => 반환 => 반환 )



* **재귀 함수에서 종료 조건이 없다면 어떻게 되는가?** 1234
  * 무한 재귀 호출이 발생할 수 있다.



* **재귀 함수와 반복문의 관계성과 차이점을 설명하시오.** 1234
  * 모든 재귀 함수는 반복문으로 작성 가능하다.
  * 재귀 함수가 복잡한 문제를 더 편하게 처리할 수 있다.
    * 재귀 함수 쪽이 더 논리적으로 쉽게 접근 할 수 있고, 눈으로도 쉽게 볼 수 있는 시점이 있다. ( 특히 복잡한 거 할 때 그렇다. )



* **재귀 함수를 잘 다루는 게 프로그래머와 어떤 연관 관계가 있는가?** 1234
  * 논리력을 평가한다.
  * 어떤 복잡한 문제를 잘 쪼개서 해결할 수 있는 가를 평가 할 수 있다.
    * 이게 부족하면 문제 해결 능력이 떨어진다.



* **재귀 함수의 장점은 무엇인가?** 1234
  * 개념적으로 매우 훌륭하다.
  * 증명이 가능하기 때문에 신뢰하고 안심할 수 있다.



* **재귀 함수의 단점은 무엇인가?** 1234
  * 효율성이 떨어진다.
    * 반복문은 중간에 연산 결과를 저장(캐싱)할 수 있지만 재귀함수는 그럴 수 없다.
    * 중복되는 것을 또 호출한다. ( FibonacciRecursive(0) 호출 FibonacciRecursive(0) 또 호출 )
  * 스택 오버플로우
    * 함수 호출 깊이에는 제한이 있다. 
      ( 컴퓨터 구조 과목에서 좀 더 자세히 설명 )
    * 반드시 모든 경우에 쓸 수 있는 것은 아니다.



* **재귀함수를 사용하기 좋은 베스트 프랙티스는 언제인가?** 1234
  * **반복문 사용하는 경우** : <u>캐싱 없이 간단한 반복문으로 작성 가능</u>한 문제 ( ex. 1 ~ N까지 수의 합 구하기 )
  * **재귀함수 사용하는 경우** : <u>그 외에는 재귀 함수로 우선 작성</u>
    * 설계 및 이해가 용이하기 때문이다.
    * <u>BUT, 아래의 경우 반복문으로 코드 리팩토링 ( code refactoring )</u>
      * 스택 오버플로우 발생 : 함수 호출의 최대 깊이를 확정할 수 없을 때
      * 효율성 문제 : 성능상의 문제를 발견 



* **재귀 함수와 성능에 관한 논쟁은? **1234
  * 재귀 함수는 성능에 문제가 있기 때문에 많이 안 쓰인다는 낭설이 있지만 사실이 아니다. 
  * 실전에서도 많이 쓰이지만 특정 문제가 있을 경우에만 코드 리팩토링을 진행해야 한다.
  * 재귀함수가 이해하기도 쉽고 읽고 쉽고, 유지보수(실수 방지)에도 좋기 때문에 일반적인 경우에는 재귀함수를 사용하는 것이 좋다.



* **재귀함수와 수학의 어떤 부분과 연관성이 있는가?**  1234
  * 수학적 귀납법과 밀접하다.
  * **수학적 귀납법**이 익숙지 않기 때문에 반복문의 선호도가 높은 것이다.



* **수학적 귀납법에 대해 설명하시오.** 123

  1. **n이 0일 때** 위의 식이 **성립**하는지 **확인**한다.
     ( 종료 조건 확인 )
  2. **0부터 k까지**의 식이 위의 식과 **성립**한다고 **가정**한다. 
  3. **0부터 (k+1)까지**의 식이 위의 식을 **만족** 하는지 **증명**한다.

  * 즉, 0일 때, 1일 때, 2일 때 모두 참이라는 것이 증명 되는 것이다.



* **재귀 함수와 신뢰에 대해 논하시오.** 123
  * 함수는 신뢰의 문제지만 재귀 함수는 더 큰 신뢰를 요구한다.
  * 호출하면 정확한 반환이 올 것이라는 믿음이 있어야 한다.
    * 이 믿음의 마지막에는 종료 조건을 만족한 반환이 올 것이라는 믿을 가져야 한다.



* **개인적인 재귀함수 마인드 3가지를 설명하시오.** 1

  작은 문제 해결 방식을 활용해 더 큰 문제를 해결한 다는 마인드로 접근한다. ( **n개**의 식 **가정**하는 단계라고 볼 수 있다. )

  * 분류 사고 방식 : n개, n-1개 묶음 단위로 분류한 사고 방식
  * 맡기는 사고 방식 : n-1개에 해결을 맡기는 사고 방식
  * 매개변수 재귀호출



* **개인적인 함수 작성법을 설명하시오.**  1

  1. 재귀함수를 3가지 생각을 가지고 구상해 본다. 

     * 트리 ( 구상 )

     * 재귀 함수 마인드 - 3가지 ( 구상 )

       작은 문제 해결 방식을 활용해 더 큰 문제를 해결한 다는 마인드로 접근한다. ( **n개**의 식 **가정**하는 단계라고 볼 수 있다. )

       * 분류 사고 방식 : n개, n-1개 묶음 단위로 분류한 사고 방식
       * 맡기는 사고 방식 : n-1개에 해결을 맡기는 사고 방식
       * 매개변수 재귀호출
       
     * 수학적 귀납법 ( 실행 )

  2. 종료 조건 - 정하기
     * **0, 1**의 값이 나오는 것을 본다.
     * 맨 끝에서 생각 : 0 또는 1 등 마지막에 있는 종료 조건에 행위를 검증해 본다.
     
  3. 3번째 항 생각 : 3번째 항이 어떻게 나오는지 확인한다.
  
  4. 맨 앞에서 생각 : n개, n+1개 묶음 단위로 행위를 진행해보기
     * **n**이 돈다는 **가정**, **n+1**개 **증명**
     * 숫자가 아주 큰 단위까지 검증했다는 가정을 검증한다고 볼 수 있다.
     
  5. 테스트 케이스 - 검증하기 





## 2. 랜덤 수



* **난수 생성은 어디에 있고, 어디서 활용 되는가?**  1234
  * 거의 모든 프로그래밍 언어에 있다.
  * 게임, 디버깅 등에서 활용된다.



* **Random 클래스를 이용하여 개채를 생성하시오.**  123

  |

  ```cs
  Random luck = new Random();
  Random random = new Random();
  ```

  

* **1~9까지의 정수가 나오는 랜덤 수를 생성하시오.**  123

  |

  ```cs
  Random random = new Random();
  int number1 = random.Next(10);		// 방법 1
  int number2 = random.Next(1, 10);	// 방법 2
  ```

  

* **난수 생성기는 완벽한가?**  1234
  
  * 그렇지 않다. 사실 진정한 랜덤이 아니다. ( 오차 존재 )
  * 시드 값을 활용하는 함수이다.



* **난수 생성기과 시드값에 관계에 대해 설명하시오.** 1234
  * 시드 (seed) 값을 초기 입력값으로 하여 알고리즘을 통해 "난수"를 만들어 내는 함수
  * 그 결과는 다시 랜덤의 입력값이 된다. 
    ( 엄밀하게 항상 이런 건 아니고, 개념적 상으로는 맞다. - 중간에 알파 값도 들어간다. )
  * 즉, 시드 값이 같으면 언제나 생성된 난수의 순서가 동일하다.



* **완벽하지 않은 난수 생성기는 어떻게 해결하려 했나?** 123
  * 여러 알고리듬이 존재한다.
  * 전용 하드웨어도 존재한다.
  * 현실적인 대안은 시계 시드값이다.



* **시계 시드값은 어떻게 사용되는가?** 123

  * 이 문제를 해결하기 위해 컴퓨터에 달린 시계를 시드값으로 이용

  * new Random() 도 내부적으로 이걸 사용한다.

    ( 이걸 직접 안 해주는 언어에서는 직접 시간을 읽어서 시드값으로 넣어준다. )



* **고정된 시드값 유용성에는 뭐가 있을까?** 123
  * 디버깅
    * 같은 시드값을 사용하여 문제를 재현하고 해결할 수 있다.
  * 게임 개발
    * 네트워크 게임에서 난수에 의해 바뀌는 게임 속 로직을 두 컴퓨터에서 동일하게 적용 시킬 수 있다.
    * (ex) 게임에서 지형을 자동으로 생성 - 마인크래프트 

