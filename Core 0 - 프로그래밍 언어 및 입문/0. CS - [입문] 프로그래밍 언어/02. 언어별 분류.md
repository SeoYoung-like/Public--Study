## 02 언어별 분류 

### 1. 기계어 

* **Machine Code (=Machine Language)** 
* **Native code**

---

1. **Low Level** / ~~High Level~~
2. ~~Compiler / JIT / interpreter~~  -  **Machine**
3. ~~Strong / Weak~~ - **Machine**
4. ~~Managed~~ / **UnManaged**
5. **Procedural** ~~/ OOP / functional~~

* **물리 언어** : 기계 장치와 연관 되어 있는 언어이다.

---

<u>컴퓨터가 이해하기 쉬운 언어</u>로 비트 단위의 **0과 1(숫자 코드)**로만 표현된다. 
컴퓨터로 바로 이해할 수 있는 언어로 되어 있기 때문에 기계어 이상의 변환 과정이 필요 없다.

**CPU**가 바로 **해독**할 수 있는 유일한 언어이자 모든 **프로그래밍 언어의 종착지**다.
번역기를 통해 나오는 마지막 **<u>실행코드</u>**이다.
( 모든 언어는 이 기계어로 번역되어야 한다. )

[참고] 해커는 기계어 만으로 어떤 프로그래밍인지 해석하기도 한다.

<br>

<br>

<br>


### 2. 어셈블리어

* **Assembly Language**

---

1. **Low Level**  /  High Level
2. ~~Compiler  /  JIT  /  interpreter~~  -  **Assembler**
3. ~~Strong  /  Weak~~  -  **Assembly**
4. Managed  /  **UnManaged**
5. **Procedural** ~~/ OOP / functional~~

* **물리 언어** : 기계 장치와 연관 되어 있는 언어이다.

---

<u>인간이 이해하기 쉬운 언어</u>로 <u>문자 코드</u>를 사용한다.
기계어 비교할 때 사람에게 보다 친근한 코드이다. 

<br>

<br>

#### 1) 기능코드

**실행코드**가 되기 전 단계인 **<u>기능코드</u>** 역할을 하고 있다.

대부분의 중/고급 언어의 컴파일러에는 어셈블러가 병합되어 있다. 
그러다보니 C의 경우도 C→기계어와 같이 가는 것이 아니라 C→어셈블리어→기계어 순으로 컴파일 할 수도 있다. 
( C로 작성한 다음 어셈블리어로 최적화 한다는 것도 이런 식이다. )

가상머신 에서도 어셈블리어가 사용된다. 
Java의 바이트코드와 .NET Framework|.NET CLR의 CIL이 대표적인 가상머신 어셈블리어 이다. 
다만, 가상머신 어셈블리어는 다양한 자료형을 지원하거나 함수를 지원하는 등 실제 어셈블리어와는 차이를 보이며, 
대개 JIT 컴파일러를 거치거나 인터프리터를 통해 해석된다.

<br>

<br>

#### 2) 기계어와 일대일 대응

대부분 **기계어랑 일대일 대응**이 가능하다.

* 이 때문에 '저수준 언어'라고 부르기도 한다.

* **명령어 종류**   -   ADD, SUB, MUL, DIV / JMP / LOAD, WRITE

* **과정 예시**       -  (ex) MOV는 10, ADD는 20, MUL은 30

  [   어셈블리어        =>                            기계어(2진수)                 ]
    MOV   R1,   3       =>    0000 1010   0000 0001   0000 0011
    MOV   R2,   4       =>    0000 1010   0000 0010   0000 0100
    ADD    R1,   R2    =>    0001 0100   0000 0001   0000 0010

![image-20230602111338462](./assets/image-20230602111338462.png)

```assembly
MOV R1, 3  	 ; 숫자 3을 R1에 저장
MOV R2, 4  	 ; 숫자 4를 R2에 저장
ADD R1, R2   ; R1과 R2의 값을 더한 후 그 결과를 R1에 저장
```

<br>

<br>

#### 3) 비통일 된 규격

기계어는 <u>CPU가 채택한 ISA에 따라 다 다르기 때문에 어셈블리어의 명령어 역시 통일된 규격이 없다.</u>
( 또한 <u>문법 아키텍처에 따라서도 다르고 어셈블러의 종류에 따라서도 문법/매크로 등이 제각각이다.</u> )

<br>

<br>

#### 4) 저수준 ~ 고수준 언어

인간이 이해할 수 있는 문자코드를 사용한다는 점에서 **'고수준 언어**'로 불리기도 하며,
고급 언어와 기계어 사이에 있다 하여 **'중간 언어'**라고 불리기도 하며,
기계어와 일대일 대응이 가능하다 해서 **'저수준 언어'**라고 불리기도 한다.

<br>

<br>

<br>

### 3. C

---

1. **Low Level**  /  High Level
2. **Compiler**  ~~/  JIT  /  interpreter~~ 
3. **Strong**  /  ~~Weak~~
4. ~~Managed~~  /  **UnManaged**
5. **Procedural** ~~/ OOP / functional~~

---

유닉스 개발을 위해 C언어 개발했다.
( 어셈블리어로 유닉스 개발을 마치고, C언어를 개발 한 이후 유닉스를 새로 작성하게 된다. )

B언어를 계승한 다는 의미에서 C를 붙였다.

자원 관리를 빡빡하게 해야 할 때 사용된다. ( 자원 최적화 )
하드웨어와 밀접하다. 
어셈블리어를 삽입할 수도 있다.

C 언어의 경우에는 사람이 이해하기 편한 문법 구조로 되어 있지만 
기계어의 명령 구조와 유사한 문법들도 가지고 있어서 '중급 언어(Middle-Level Language)'라고 부르기도 합니다. 

( low와 high의 중간 )

보안상으로 보면 초보자와 숙련자 사이의 격차가 크기 때문에 공격을 많이 당하기도 한다.
<u>**근본 거의 모든 것의 시작**</u> - 후속 언어들에게 많은 영향을 끼친 언어이다.

C언어 자체로 배울 양은 적지만 하드웨어 자체를 알아야 하기 때문에 배우기 어려운 언어이다.
10년뒤 살아남는 개발자가 되기 위해서는 C를 이용할 줄 알아야 한다. ( 정확히 말하면 컴퓨터를 알아야 한다. )

(정신) Trust the programmer - 다른 의미로는 프로그래머가 해야 할게 많다.
(특징) 포인터 메모리 직접지정
(사용처) 임베디드 프로그래밍, 운영체제

<br>

<br>

<br>

### 4. C++

---

1. ~~Low Level~~  /  **High Level**
2. **Compiler**  ~~/  interpreter~~ 
3. **Strong**  ~~/  Weak~~
4. ~~Managed  /~~  **UnManaged**
5. ~~Procedural /~~ **OOP** ~~/ functional~~

---

비야네 스트로스트럽 교수가 창시했다.

C언어의 확장판이다. 

C문법과 호환이 되는 특징 덕에 많은 프로그래머의 지지를 받았다.
C에 Class라는 객체지향 프로그래밍 패러다임이 들어간다. 

Class라는 객체지향 개념이 들어간다. 
( 비슷한 예로 JavaScript - TypeScript가 있다. )

로우 레벨 퍼포먼스, 메모리 관리를 직접 관여할 수 있어 임베디드에서 높은 속도 퍼포먼스를 요하는 경우 사용된다. 

굉장히 난해서 프로그래밍 언어 중 가장 사용하기 어려운 언어이다.

(사용처) 포토샵, 프리미어 프로, 게임 서버, 임베디드 등
(키워드) STL

<br>

<br>

<br>

### 5. JAVA

객체지향 대표 언어 - 로우레벨 보다는 하이레벨과 가까운 언어

---

1. ~~Low Level~~  /  **High Level**
2. ~~Compiler  /~~  **JIT**  ~~/  interpreter~~ 
3. **Strong**  ~~/  Weak~~
4. **Managed**  /  UnManaged
5. ~~Procedural /~~ **OOP** ~~/ functional~~

---

* 오라클과 함께 하는 생태계다. - Oracle 생태계 / Oracle 기업

* JVM이라는 가상머신 기반의 언어다. 
  ( Byte 바이트 코드를 활용하기에 호환성이 좋다. )

* 레퍼런스가 많고, 안정성이 좋지만, 문법이 복잡하고, 타입 지정 해야 해서 조금 복잡하다.

(점유율 지역) 한국
(사용처) 정부, 기업, 은행 - 기업용 어플리케이션, 서버, 앱 - 시스템, 앱, 웹 다 가능 

<br>

<br>

<br>

### 6. C#

---

1. ~~Low Level~~  /  **High Level**
2. ~~Compiler  /~~  **JIT**  ~~/  interpreter~~ 
3. **Strong**  ~~/  Weak~~
4. **Managed**  /  UnManaged
5. ~~Procedural /~~ **OOP** ~~/ functional~~

---

* 닷넷 시스템과 함께하는 생태계다. - .Net 생테계 / MS 기업
* 가상머신 기반의 언어로 ( 닷넷을 활용하기에 호환성이 좋다. )
* C++보다 JAVA에 더 유사하다. 마이크로소프트 JAVA 
* 기업용으로 만들어진 프로그래밍 언어다.
* 메모리 관리 : 가비지 콜렉터 GC가 책임 진다.
* 플랫폼 이식 : CLR 이 책임 진다.
  * 윈도우, 리눅스 , macOS, 안드로이드, iOS 등
* 일관된 클래스 라이브러리

(점유율 지역) 유럽, 미국 등
(사용처) "기업용 어플리케이션", 서버, 게임 - 응용프로그램, 웹 서버, 게임 unity 3D 등 가능 

> MS가 발목 잡아서 윈도우즈를 벗어날 수 없다. 
> 지금은 위기를 느끼고 멀티플랫폼 이라는 한계를 넘어서고 있다.

<br>

**[ C++ / C# ]**

* 동작 속도 : C++ >>> C#

* 개발 속도 : C# >> C++

<br>

<br>

<br>

<br>

## 참고

* 뉴렉처 - [컴퓨터 프로그래밍을 하기 위한 사전지식 : 6강 ~ 12강](https://www.youtube.com/playlist?list=PLq8wAnVUcTFXna0fCAsElIj2qayRqvGjk)
* POCU 프로그래밍 입문 ( with C# )
* 위키백과

