# 4. 프로젝트 빌드와 컴파일 에러

## 1. **프로젝트 ( with Visual Studio )**

* 소스코드 ( Source ) : 프로그래밍 코드가 들어있는 파일이다.
* 프로젝트 ( Project ) : 프로그램을 개발하는 데 사용하는 각종 파일을 모아두는 보관함 ( 컴퓨터 코드가 담긴 파일이 보관된다. )
* 솔루션 ( Solution ) : 여러 개의 프로젝트를 모아두는 보관함
* 템플릿 ( Template ) : 프로그램을 만들 때 공통적을 사용하는 기본 코드를 제공하는 툴

솔루션 >> 프로젝트 >> 소스코드





**확장자**

프로그래밍 언어마다 확장자가 다르다.







## 2. 빌드와 컴파일

**[ 빌드 과정 ]**

![img](./assets/img-1687156571612-1.png)

---

-  그림 1번은 컴파일(compile)에 해당한다.
-  그림 2번은 링크(Link)에 해당한다.
-  1번과 2번 두과정을 합쳐서 빌드(Build)라고 한다.

---

\* 소스코드(원시코드) : 컴퓨터 프로그램을 (사람이 읽을 수 있는) 프로그래밍 언어로 기술한 글을 말한다.

\* 목적코드(목적파일) : 컴파일러나 어셈블러가 소스코드 파일을 컴파일 또는 어셈블해서 생성하는 파일이다.







### 2.1. **컴파일, 컴파일러란?**

- 컴파일러(Compiler) : 컴파일을 실행하는 프로그램을 말한다.

- 컴파일(Complile) : 원시 코드에서 목적 코드로 옮기는 과정을 말한다.

  - 컴파일은 그림 1번을 말한다. ( 넓은 의미의 컴파일 뜻 으로는 빌드 그림 전체를 말하기도 한다. )

  

 



### **2.2. 링크(Link), 링커(Linker)란?**

- 링커(Linker) : 링크를 실행해주는 프로그램입니다.
- 링크(Link) : 컴파일러의 결과물인 목적코드(Object code)들을 최종 실행 가능한 실행파일(.exe) 만들기 위해 연결 ,병합 해주는 작업입니다.
  - 정적 링크(static link)와 동적 링크(dynamic link)로 나뉜다.
    - **정적 링크** : 컴파일된 소스파일을 연결해서 실행가능한 파일을 만드는 것입니다.
    - **동적 링크** : 프로그램 실행 도중 프로그램 외부에 존재하는 코드를 찾아서 연결하는 작업을 말합니다.(동적 링크는 링커가 필요가 없다.)

 

 

 

 

### 2.3. 빌드(Build),빌드 툴(Build tool)란?

- 빌드(Build) : 소스 코드 파일을 실행할 수 있는 독립 소프트웨어 가공물로 변환하는 과정을 말하거나 그에 대한 결과물을 일컫는다. 쉽게 말하면 코드를 프로그램으로 번역하는 과정이다.
  - **컴파일과 링크 두 개의 과정을 합친 것을 뜻한다.**
- 빌더 툴(Build tool) : 빌드를 수행하는 도구를 말한다.
  \- 종류 : Ant, Maven, Gradle 
  \- 빌드 툴이 제공하는 기능은 전처리(preprocessing), 컴파일(Compile), 패키징(packaging), 테스팅(testing), 배포(distribution) 이 있다.

 

[참고] https://kimvampa.tistory.com/27

---













## 3. 컴파일(Compile)과 에러

### 3.1. 컴파일(Compile)관 런타임(runtime)?

**컴파일(Compile)**

* 소스코드를 기계어 또는 VM(Virtual Machine)이 이해할 수 있는 언어로 변경하는 행위이다.

  ( 기계가 이해할 수 있는 언어를 기계어라고 부른다. )

* 컴파일을 할 때, 오류(error) 또는 경고(warning)가 발생할 수 있다.

> ----
>
> **컴파일러(compliler)** 
>
> * 컴파일 할 때 사용하는 프로그램이다.
>
> * CLI : 커맨드 라인 환경의 특정 프로그램
>
> - GUI : IDE ( 통합개발 환경 ) 
>
>   (ex) 비주얼 스튜디오 ( 컴파일러가 포함되어 있다. )
>
> ---



**런타임(runtime)**

* 컴파일 과정을 마친 프로그램이 실행되어 동작 되는 것을 런타임이라고 합니다.





### 3.2. 오류와 경고

오류와 경고는 처음 보기에 큰 차이가 없어 보이지만 컴파일러에게 이 둘은 완전 다른 개념입니다.



#### 1) 컴파일 오류 ( error )

컴파일 오류는 작성된 소스 코드로부터 제대로 작동하는 프로그램이 나올 수 없을 때 발생합니다. 
컴파일러가 코드를 이해할 수 없기 때문에 실행 파일(.exe)을 만들어내지 않는다.

* 작성한 코드가 프로그래밍 언어의 규격에 위반 되는 경우 발생한다.

  * **오류가 있기 때문에 exe 파일이 생성되지 않는다.**
    따라서 프로그램을 실행조차 할 수 없다. ( exe 파일이 없으니까 )
* 컴파일 오류의 예로는 **구문(syntax) 및 형(type) 오류**가 일반적이다.
  * 함수 정의
    * 중괄호를 생략
    * 반환형을 생략
    * 불완전한 구조체의 멤버에 접근
  * 구문
    * 세미콜론(;)을 빼먹는 사소한 실수
    * 접근할 수 없는 데이터에 접근을 시도하는 것 등이 있다.



---



**[ 컴파일 오류의 유용성 ]**

컴파일 오류는 프로그램 실행 중에 문제를 발견하는 것보다 이득이다.

프로그램 실행 중에 문제가 있는 것을 **버그**라고 한다. 
버그가 나는 상황을 프로그래머가 직접 재현하고 고쳐야 한다.

그렇기 때문에 컴파일 때 잡으면 아주 간편한 것이다.



----



**[ 오류 창과 실행 창 ]**

- 오류 창이 안 보일 경우 - 스튜디오의 보기 > 오류 목록 ( 클릭! )

![image-20230501163049612](./assets/image-20230501163049612-1687156571613-2.png)

---

![image-20230501163212780](./assets/image-20230501163212780-1687156571613-3.png)

![image-20230501163224568](./assets/image-20230501163224568-1687156571613-5.png)

![image-20230501163252101](./assets/image-20230501163252101-1687156571613-4.png)













#### 2) 컴파일 경고 ( warring )

컴파일 경고는 똑똑한 컴파일러가 코드에 문제가 될 수 있는 부분에 대해 미리 경고를 주는 것입니다. 
<u>당장 문제가 되지는 않기 때문에 실행 파일이 만들어지기는 한다는 점에서 차이가 난다.</u> 

컴파일 경고의 예로는 선언된 변수가 사용되지 않고 있는 것이 대표적입니다.
( 컨트롤이 non-void 함수의 끝에 도달(control reaches end of non-void function), 캐스팅(Casting) 없이 포인터에서 정수를 만들려고 하거나(attempt to make integer from pointer without a cast) 등이 있습니다. )

* 경고 : 프로그래머의 실수처럼 보이는 것을 똑똑한 컴파일러가 찾아주는 것이다.
  * exe 파일 생성 : 경고가 있더라도, exe 파일이 생성된다.
  * 프로그램 실행 가능

---



**[ 경고의 안일함이 주는 위험성 ]**

경고는 실제로는 문제가 아닌 경우가 대부분이다. ( 10% 정도는 문제가 있을 수도 있다. )

그러나 경고를 수정하지 않는다면, 나중에 진짜 문제를 찾기 어려울 수 있다.

---

* 이미 100개의 경고가 있는데 새로 추가된 경고 하나가 눈에 보일까?

오류는 치명적이고 실행 파일도 만들어지지 않으니 빨리 고치고, 경고는 실행 파일이 만들어 지니 무시해도 된다고 생각한다면 큰 오산입니다. 

컴파일 경고 중 아주 드물게 치명적인 버그를 만들어내는 경우가 존재합니다. 

평소에 경고를 고치지 않는 습관을 들이다가 나중에 경고가 100개, 200개 쌓이면 치명적인 경고를 못 보고 넘어갈 위험이 존재하죠.

---

* 실제 업계에서는 릴리즈 빌드 시에 경고를 오류처럼 다루기도 한다.
* 경고는 언제나 고치자!



![image-20230501163505603](./assets/image-20230501163505603-1687156571613-6.png)

![image-20230501163621811](./assets/image-20230501163621811-1687156571613-7.png)









#### 3) 런타인 오류 ( runtime error )

런타임 에러는 프로그램 실행 중에 발생하는 에러입니다.
일반적으로 프로그램에서 수행 불가능한 작업을 시도할 때 발생합니다.

프로그램 설계 미숙일 수도 있으나, 매우 드물게 하드웨어 결함이 원인일 수도 있습니다.
만약 어떤 소스코드가 이미 실행 가능한 프로그램으로 컴파일 되었다고 해도 이것은 여전히 프로그램 실행 중에 버그를 일으킬 수 있습니다.

예상치 못한 오류 또는 충돌로 동작하지 않을 수 있는데 이렇게 프로그램이 실행 중에 발생하는 에러를 런타임 에러라고 합니다.

(ex)  0 나누기 오류, 널(NULL) 참조 오류, 메모리 부족 오류 등이 있습니다.





#### 4) 시간 초과

* **TLE : Time Limit Exceeded**

너무 느린 알고리즘으로 짠다거나 루프문을 잘못 사용했을 때 발생합니다.

예를 들어 버블 정렬을 사용하면 시간 복잡도가 O(n^2)인데
퀵 정렬은 상황에 따라 O(NlogN)까지 시간 복잡도가 단축될 수 있습니다.

이 때 n이 100개 정도면 상관이 없지만
n이 100000개면 버블 정렬 사용시 
n*n=100000000000으로 시간 초과가 될 것입니다.*
*따라서 100000*log100000이 훨씬 빠를 것입니다.

무한 루프에 빠져서 시간 초과가 되는 경우도 있습니다.

반드시 루프가 제대로 종료되는지 체크해야합니다.







### 3.3. 디버그(debug)와 릴리즈(release) 빌드

디버그 버전은 디버깅용으로 빌드하고 릴리스 버전은 최종 릴리스 배포용으로 빌드합니다. 
성능에 최적화되어 있는 것은 릴리스 빌드이나 디버그하는 데 더 적합한 것은 디버그 빌드입니다.

이 모든 과정(디버그 빌드, 릴리스 빌드)은 컴파일러가 알아서 해준다.

* **디버그 빌드** : 개발자가 개발 중에 사용하는 실행파일
  * 디버깅 : 디버깅을 위한 유용한 많은 정보가 담겨져 있다.

  * 최적화 : 거의 안 됨

  * 성능 : 성능은 별로다. 
    [주의!] 배포를 디버그 빌드로 하면 해킹 당할 위험도가 높아진다.

* **릴리즈 빌드** : 실제 사용자(고객)에게 배포하는 실행파일
  * 디버깅 : 디버깅을 위한 정보는 적다.
  * 최적화 : 최적화 집중
  * 성능은 디버깅 모드보다 엄청 빠름 ( 때론 수십 배 이상 차이가 난다. )

![image-20230501163827752](./assets/image-20230501163827752-1687156571613-8.png)

